# 7.14等待和终止进程

### wait()系统调用

*  为何要使用wait()系统调用？因为子进程执行完成调用exit()后，虽然可以释放掉用户态的资源，但是位于内核态中的资源却没有办法释放，比如说子进程的PCB。这就需要父线程来将子进程的资源完全释放。
* wait()调用是被父进程用来等待子进程的结束。一个子进程向父进程返回一个值，父进程通过wait()调用接受这个值并处理
* wait()调用的具体功能：
    * 使父进程进入睡眠等待子进程执行结束并调用exit()
    * 当子进程调用exit()后，操作系统解锁父进程，并且通过exit()传递得到的返回值作为wait()调用的一个结果（连同子进程的pid一起）
    * 父进程将子进程的所有资源回收。

### exit()系统调用

* 进程结束执行之后，它调用exit()。
* exit()调用的作用：
    * 将这个程序的结果做为参数传递给父进程的wait()
    * 关闭所有打开的文件，连接等等。
    * 释放用户态的资源：内存；大部分支持进程的操作系统结构。
    * 检查父进程是否存活：
        * 如果是，保留结果值知道父进程需要。
        * 调用exit()后，但是父进程的wait()还没有执行完毕这一段时间，子进程没有真正死亡，而是处于僵尸态
    * 清理所有等待的僵尸进程。
* 如果父进程已经死亡，僵尸进程如何清理？操作系统的祖宗`root`进程会定期扫描进程控制块的列表，查看是否存在僵尸进程，如果存在，就会代替其父进程完成清理操作。

### 状态转变的补充

* exit()执行之后，但父进程wait()执行完毕前，处于僵尸状态。
* fork()调用的时候，会创建一个新的进程（New）
* exec()调用时，进程可能处于不同状态：
    * 执行exec()时，进程一开始处于Running状态
    * 执行exec()时，会重新载入程序的代码，数据，这个时候会进入阻塞状态。