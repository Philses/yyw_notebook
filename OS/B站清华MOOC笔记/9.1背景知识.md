# 9.1背景知识

### 独立线程与合作线程

* 独立线程：
    * 不和其它线程共享资源或状态
    * 确定性：输入状态决定结果
    * 可重复性：起始条件相同，得到的结果相同
    * 调度顺序不会影响执行结果
* 合作线程：多道程序交互非常普遍
    * 多个线程中共享状态或资源
    * 不确定性
    * 不可重复性
    * 不确定性和不可重现意味着bug可能是间歇性发生的。

### 为啥么要进行线程的合作

* 进程/线程，计算机/设备需要合作
* 共享资源
* I/O操作和计算可以重叠，从而实现加速
* 模块化：将大程序分解成小程序。

### 不确定性问题（举例）

* 程序调用`fork()`函数来创建一个新的进程时，需要给新创建的线程一个PID，操作系统会在内核中维持一个全局变量`next_pid`。`new_pid = next_pid++;`
* 上一条代码写成汇编：
    * `LOAD next_pid Reg1`(`Reg1`表示某个寄存器)
    * `STORE Reg1 new_pid`
    * `INC Reg1`
    * `STORE Reg1 next_pid`
* 独立线程执行这个语句不会出现问题。
* 如果有两个进程并发执行，调度算法在时间片用完时进行上下文切换，而一个线程还没有执行完全部4条汇编指令，此时可能出现错误。
    * 列入当前`next_pid = 100`， 有两个进程并发执行，都要创建新的进程，理论上结果应该是，两个新进程的PID 为100，101。创建结束后`next_pid = 102`
    * 但是如果调度算法让两个进程的执行方式为：
        * 第一个进程执行完第二条汇编，上下文切换至第二个进程执行完四条汇编，再切换到进程1完成剩下的两条汇编指令。
        *  注意，上下文切换会将寄存器的状态保持在PCB中，当下一次切换回来的时候，再将寄存器状态恢复到切换前的状态。
        * 那么，进程1切换时，它创建的新进程的PID为100，没有来得就增加寄存器的值就进行了切换。
        *  进程2将100这个值放到寄存器中，创建的新进程的PID为100，然后寄存器的值+1，再将寄存器的值存放到`next_pid`中，此时`next_pid = 101`。
        *  然后切换回进程2，执行第三条汇编，寄存器的值恢复为切换之前的100，加1后存放进`next_pid`中，此时`next_pid = 101`。
        * 于是两个新进程的PID都为100，`next_pid = 101`，和预期结果不相符。

