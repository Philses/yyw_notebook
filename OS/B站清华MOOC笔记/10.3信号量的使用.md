# 10.3信号量的使用

### 信号量特点

* 信号量是整数
* 信号量是被保护的变量
    * 初始化完成后，信号量只能通过 P() 与 V() 来修改值
    * 操作必须是原子的
* P() 信号量减少1，如果信号量<0，阻塞当前线程； V() 信号量增加1，如果信号量 <= 0，唤醒一个线程。
* 信号量是公平的。
    * 在实践当中，唤醒线程按照FIFO（先进先出）的顺序
* 两种类型信号量
    * 二进制信号量：只有0/1两个值，可以实现Lock的功能
    * 一般/计数信号量：信号量可以是任何非负的初值。在锁机制中，访问某一个内存空间只能有一个线程，但是使用信号量，访问某一个内存空间可以有多个线程。
* 信号量可以实现的功能：互斥与条件同步。

### 用二进制信号量实现互斥

* 类似于锁机制。信号量初值为1。

* ```
    mutex = new Semaphore(1);
    
    mutex -> P();
    Critical Section // 临界区
    mutex -> V();
    ```

* `mutex -> P();`类似于获得锁，当第一个线程进入临界区后，信号量变为0，下一个线程再想进入灵界区就使得信号量为-1，阻塞。直到第一个线程执行完调用 V(),使信号量变为0，然后唤醒一个阻塞线程。 

* `mutex -> V();`类似于释放锁。

### 用二进制信号量实现调度约束（同步操作）

* 假如有两个线程A，B。要让A在B都某一行之后才能执行，可以这样书写A, B的逻辑

```
condition = new Semephore(0);

A:                    B:
condition -> P();       .....
						.....
						condition -> V();
```

* 信号量初值为0。
* 在B执行完`condition -> V()`之前，A执行`condition -> P();`都会使得信号量等于-1，发生阻塞。
* P()用于等待，V()用于发出可执行的信息。

### 条件同步

* 举例子：

    * 有多个生产者线程向缓冲区生产数据；
    * 有多个消费之线程拿出缓冲区的数据；
    * 正确性要求：
        * 任何一个时刻，只能有一个线程操作缓冲区（互斥）
        * 当缓冲区放满东西，生产者必须等消费者从里面拿走东西。（调度/同步约束）
        * 当缓冲区为空，消费者必须等生产者往里面放东西。（调度/同步约束）

* 每一个约束使用一个信号量：

    * 一个二值信号量，管理互斥
    * 一个一般信号量 empty，表示剩余多少可放的空间
    * 一个一般信号量 used，表示剩余多少可取空间

* 信号量的初始化，假定缓冲区总空间为n

  * ```
    mutex = new Semephore(1)
    empty = new Semephore(n) // 初始时刻全都可以放入东西
    used = new Semephore(0) // 初始时刻，没有可取的东西
    ```

* 互斥的设置

    * ```
        Deposit(c){ // 生产者线程
        	mutex -> P();
        	Add c to buffer;
        	mutex -> V();
        }
        ```

    * ```
        Consumer(c){ // 消费者线程
        	mutex -> P();
        	remove c to buffer;
        	mutex -> V();
        }
        ```

* 同步约束的设置

    * ```
        Deposit(c){ // 生产者线程
        	empty -> P(); // 缓冲区要有空余空间可以放入c，才不会发生阻塞
        	mutex -> P();
        	Add c to buffer;
        	mutex -> V();
        	used -> V(); // 生产者线程执行完功能后，有c被放入缓冲区，如果此时 used <= 0,说明消费者线程有阻塞，已经有c进入缓冲区，所以要唤醒一个生产者线程。
        }
        ```

    * ```
        Consumer(c){ // 消费者线程
        	used -> P(); // 缓冲区要有东西可取，消费者才运行执行，否则发生阻塞等待缓冲区有东西可取
        	mutex -> P();
        	remove c to buffer;
        	mutex -> V();
        	empty() -> V(); // 消费者消耗了一个c，缓冲区有空余位置可放入，此时 empty <= 0，会唤醒一个生产者线程。
        }
        ```

* 两个V()操作可以互换顺序，因为本身V不会阻塞。

* 两个P()操作互换顺序会导致死锁。

    * 比如生产者调用了 `mutex -> P()`后，再调用`empty -> P();`在empty上阻塞，要等待消费者线程执行完功能后调用`empty() -> V();`，当时消费者进程执行`mutex -> P()`时阻塞。
    * 所以要正确设置P()的顺序。

