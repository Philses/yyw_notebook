# 11.7 死锁检测和死锁恢复

* 运行系统进入死锁状态，但会进行是否死锁状态的判断，如果是，就进行死锁恢复。

### 等待图检测算法

* 将资源分配图简化，只留下进程结点，变为进程等待图。 Pi --> Pj : 进程i等待进程j
* 定期调用检测算法来判断有向图中是否存在环。
* 算法需要$n^2$次操作，n是图中顶点数目。

### 基于安全状态判断算法

* 数据结构：
    * Available(剩余可用空闲量)，`Available[m]`长度为m的向量，`Available[j] = k`表示类型为`Rj`的资源还有k个实例可用。
    * Allocation(已分配量)，`Allocation[n][m]` n * m 的矩阵。`Allocation[i][j] = k`表示进程`Pi`已经获得类型为`Rj`的资源`k`个实例。
    * Request(各线程请求资源)，n * m 的矩阵。`Request[i]`是一个长度为m的向量，表示进程i请求的资源
    * finish[n]，表示各个进程是否执行完成
* 初始化：
    *  work = Available
    * if Allocation[i] > 0, then finish[i] = false
* 2.找出一个i使得：
    * finish[i] = false;
    * request[i] <= work // 请求的资源少于当前空闲资源
    * 如果找到了跳到3，否则跳到4
* 3.可完成进程的处理
    * finish[i] = true;
    * work = work + Allocation[i] // 将进程拥有的资源释放到当前空闲资源中
    * 跳转到2
* 4.如果存在 finish[i] = false， 表面发生死锁。此外，如果finish[i] = false，那么进程i死锁。
* 算法的时间复杂度为$O(mn^2)$，开销很大，所以死锁检测的过程一般是调试时使用。
* 多久调用一次检测算法，不太好确定

### 死锁恢复

* 在一个时间内终止一个进程直到死锁消除
* 终止进程的顺序如何确定？
    * 优先级
    * 进程运行时间的长短
    * 进程占用的资源……