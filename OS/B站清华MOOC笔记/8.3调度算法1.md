# 8.3调度算法1

### 先到先处理的调度算法

* First come， First Service。FCFS

* 使用一个FIFO队列：如果进程在执行中阻塞，队列中的下一个会得到CPU
* 优点：实现简单
* 缺点：
    * 平均等待时间波动大，平均周转时间波动大（比如队列中进程的执行时间为[9 3 3]时，平均周转时间为$9 + (9+3)+(9+3+3))/3=12$; 比如队列中进程的执行时间为[3 3 9]时，平均周转时间为8）
    * 话费时间少的任务排在花费时间长的任务后面（相应就慢了）
    * 可能导致I/O和CPU之间的重叠处理，因为没有考虑抢占。

### 短进程优先

* 按照预测的执行时间来将任务入队，时间最短的在就绪队列的前面，调用时选择就绪队列中的第一个进程执行。可抢占或者不可抢占。

* Shortest Process Next， SPN 非抢占式的
    * 如果有一个新进程进入就绪队列，其执行时间比当前正在运行的进程的剩余执行时间更短，不会让当前进运行的进程被打断。新进程放入就绪队列最前面，等到当前进程执行完毕后再执行。
* Shortest Remaining Time，SRT 抢占式。
    * 如果有一个新进程进入就绪队列，其执行时间比当前正在运行的进程的剩余执行时间更短，会让当前进运行的进程被打断，立即开始执行新的进程，将被打断的进程放入就绪队列最前面。
* 短进程优先的优点：最优平均等待时间。
* 短进程优先的缺点：
    * 可能导致饥饿，有违公平性原则。连续的短任务会不断加塞到就绪队列前面，使得执行时间长的进程饥饿，执行时间长的进程的平均等待时间变长。
    * 进程的实现需要预测执行时间（剩余执行时间）这实际上是做不到的。
* 如何解决预测执行时间的问题：预估执行时间
    * $T(n+1)=at(n)+(1-a)T(n)$
    * 其中$t(n)$为第n段时间内的执行时间。$T(n+1)$为n+1段时间内预估的执行时间。
    * $T(N+1) = at(n)+(1-a)at(n-1)+(1-a)^2at(n-2)+....$

### 最高响应比优先

* 在SPN调度的基础上改进，排序依据改为 R=(W+S)/S。（等待时间+执行时间）/执行时间
* 选择R值最高的进程优先执行，关注进程等待了多长时间，对交互性友好。
* 可以防止无限期推迟，防止饥饿现象的发生。
* 缺点：
    * 执行时间依然只能通过预估
    * 不可发生抢占。也就是R更高的进程进入就绪队列，也不会停止当前的进程。