# 7.10线程的实现

主要有三种实现方式

1. 用户线程：在用户空间实现
2. 内核线程：在内核中实现
3. 轻量级进程：内核中实现，支持用户线程

### 用户线程与内核线程对应关系

1. 多对一：多个用户线程对应一个内核线程。
2. 一对一：
3. 多对多：

### 用户线程实现：

* 在用户空间实现的线程机制，不依赖于操作系统的内核，由一组**用户级的线程库函数**来完成线程管理，包括包括线程的创建，终止，同步和调度等。

* 操作系统只能看到进程信息，进程中的线程信息操作系统无法知道。操作系统不直接参与线程调度，可用于不支持线程技术的多进程操作系统。
* 每个进程都需要它自己私有的线程的TCB列表，用来跟踪记录它的各个线程的状态信息（PC, 栈指针，寄存器），TCB由线程管理库来维护。
* 用户线程的切换由线程库函数来完成，无需进行用户态/内核态的切换，速度非常快。
* 由于不属于内核管理，每个进程可以自定义自己的线程调度算法。
* 缺点：
    * 阻塞性的系统调用，会使得整个进程等待，即便其他线程没有发出调用。因为OS只能感知到进程，一个线程发出阻塞性调用，OS就会认为该进程发出阻塞调用，从而让进程阻塞，其余线程也就等待了。
    * 一个线程开始后，除非该线程主动让出CPU，否则其它线程一直无法运行。因为线程管理库没有办法中断线程。OS可以，因为OS可以管理中断，特别是时钟中断。
    * 时间片分配给进程，那么多线程执行时，每个线程得到的时间片更少了，运行较慢。

### 内核线程

* 指操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建，管理和终止。
* 进程的PCB，线程的TCB都在操作系统内核中，PCB管理一系列TCB。进程负责资源管理。
* 线程的创建，终止和切换都是通过系统调用/内核函数的方式进行，系统开销较大。
* 每次线程的切换都会有内核态/用户态的切换，开销较大。
* 操作系统调度单位为线程。在一个进程中，某个线程的阻塞不会影响其它的内核线程运行。
* 时间片分配到线程，所以多线程的进程拥有更多CPU时间。

### 轻量级进程