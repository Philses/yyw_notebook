# 8.6多处理器调度与优先级反转

### 多处理器调度

* 原因：现在基本是多个相同的单处理器组成一个多处理器，每个处理器运行自己的调度程序。
* 要解决的问题：进程应该放到哪一个CPU执行？如何确保多个CPU负载均衡（不出现一些特别忙，一些特别闲）
* 在单个处理器上的调度算法基本上是与通用调度算法一致。OS还需要处理CPU进程的分配调度。

### 优先级反转

* 可能会发生在任何 **基于优先级**的**可抢占**式的调度机制中
* 当系统内的环境强制使高优先级任务等待低优先级任务时发生。
    * 比如T1需要的资源被T3占用，T1在等待T3执行之后释放资源。而此时T2抢占了T3，T3没法执行完成释放，所以T1还得等T2运行。
    * 系统就会认为此时不稳定。
* 解决办法：
    * 优先级继承办法：通过共享的资源确定优先级，来将低优先级的进程动态地提升。（比如上一个例子中T3优先级提高到T1，这样就不会被T2抢占而无法释放资源）
    * 优先级天花板：
        * “资源”的优先级=max{所有可以锁定该资源的任务的优先级}。
        * 占用该资源的进程，优先级动态提升为资源的优先级。这样确保了访问了某个资源后，能够执行完成释放资源。（除非另外一个进程的优先级比这个资源更高，才会发生抢占。）