# 4.2非连续内存分配：分页

### 分页地址空间

* 与分段的区别：段的长度是可变的，页的大小是固定的。相似：分页也需要页号与偏移。
* 划分物理内存至固定大小的帧，大小是2的幂。
* 划分逻辑地址空间至相同大小的页，大小是2的幂。
* 建立方案，转换逻辑地址为物理地址（pages to frames）
    * 页表
    * MMU/TLB
* 一个物理内存地址是二元组（f,o）。
    * f表示帧号（第几个帧 从0开始）。假如帧号占用了F位，那么一共有$2^F$个帧
    * o表示帧内偏移。
    * 假如一帧有S位，那么每帧有$2^S$个字节(也就是一帧的长度)。
    * 所以某一物理地址（f,o）为 $2^Sf+o$。$2^Sf$帧的长度乘帧号（第几个帧）得到该帧的起始位置（类似段的base）然后再加上偏移就得到要找的物理地址了。
* 逻辑地址空间：划分为大小相同的页。
    * 单个页的长度与单个帧的长度相等。
    * 一个逻辑地址是一个二元组（p,0）。
        * p表示页号（第几个页 从0开始）。假如页号占用了P位，那么一共有$2^P$个页
        * o表示页内偏移
        * 假如一个页有S位，那么每页有$2^S$个字节(也就是一页的长度)。
        * 虚拟地址为$2^Sp+o$。

### 分页寻址方案

* 由逻辑地址到物理地址。页号与帧号可能不相等，但是单个页与单个帧的长度是相等的，偏移量也是相等的。
* 页号与页表的索引对应，页表就是一个大数组，其值为帧号，这样就有了页号与帧号的映射。并且偏移量相等，于是就可以将逻辑地址转换为物理地址了。
* 页表由OS建立，在使用分页机制前建立好。
* 页寻址机制：
    * 页是连续的虚拟内存
    * 帧是非连续的物理内存：可以减少碎片
    * 不是所有的页都有对应的帧。

